import { Redis } from 'ioredis';
import { createServiceLogger } from './logger';

const logger = createServiceLogger('metrics');

export interface ProcessingMetrics {
  totalClaimsIngested: number;
  totalClaimsProcessed: number;
  totalRemittancesGenerated: number;
  totalErrors: number;
  payerMetrics: Record<string, {
    claimsProcessed: number;
    errors: number;
  }>;
  startTime: number;
}

export class MetricsCollector {
  private redis: Redis;
  private readonly METRICS_PREFIX = 'metrics:';
  
  constructor(redis: Redis) {
    this.redis = redis;
  }

  async incrementClaimsIngested(count: number = 1): Promise<void> {
    try {
      await this.redis.incrby(`${this.METRICS_PREFIX}claims:ingested`, count);
      logger.debug(`Incremented claims ingested by ${count}`);
    } catch (error) {
      logger.error('Failed to increment claims ingested:', error);
    }
  }

  async incrementClaimsProcessed(payerId: string, count: number = 1): Promise<void> {
    try {
      await Promise.all([
        this.redis.incrby(`${this.METRICS_PREFIX}claims:processed`, count),
        this.redis.incrby(`${this.METRICS_PREFIX}payer:${payerId}:processed`, count),
      ]);
      logger.debug(`Incremented claims processed for ${payerId} by ${count}`);
    } catch (error) {
      logger.error(`Failed to increment claims processed for ${payerId}:`, error);
    }
  }

  async incrementRemittancesGenerated(count: number = 1): Promise<void> {
    try {
      await this.redis.incrby(`${this.METRICS_PREFIX}remittances:generated`, count);
      logger.debug(`Incremented remittances generated by ${count}`);
    } catch (error) {
      logger.error('Failed to increment remittances generated:', error);
    }
  }

  async incrementErrors(context: string, count: number = 1): Promise<void> {
    try {
      await Promise.all([
        this.redis.incrby(`${this.METRICS_PREFIX}errors:total`, count),
        this.redis.incrby(`${this.METRICS_PREFIX}errors:${context}`, count),
      ]);
      logger.debug(`Incremented errors for ${context} by ${count}`);
    } catch (error) {
      logger.error(`Failed to increment errors for ${context}:`, error);
    }
  }

  async getMetrics(): Promise<ProcessingMetrics> {
    try {
      const multi = this.redis.multi();
      
      // Get basic counters
      multi.get(`${this.METRICS_PREFIX}claims:ingested`);
      multi.get(`${this.METRICS_PREFIX}claims:processed`);
      multi.get(`${this.METRICS_PREFIX}remittances:generated`);
      multi.get(`${this.METRICS_PREFIX}errors:total`);
      multi.get(`${this.METRICS_PREFIX}start_time`);
      
      // Get payer-specific metrics
      const payers = ['AETNA_001', 'BCBS_001', 'CIGNA_001', 'HUMANA_001', 'MEDICARE_001'];
      payers.forEach(payerId => {
        multi.get(`${this.METRICS_PREFIX}payer:${payerId}:processed`);
        multi.get(`${this.METRICS_PREFIX}errors:payer-${payerId.toLowerCase()}`);
      });

      const results = await multi.exec();
      if (!results) {
        throw new Error('Failed to execute Redis multi command');
      }

      let idx = 0;
      const totalClaimsIngested = parseInt(results[idx++][1] as string || '0');
      const totalClaimsProcessed = parseInt(results[idx++][1] as string || '0');
      const totalRemittancesGenerated = parseInt(results[idx++][1] as string || '0');
      const totalErrors = parseInt(results[idx++][1] as string || '0');
      const startTime = parseInt(results[idx++][1] as string || Date.now().toString());

      const payerMetrics: Record<string, { claimsProcessed: number; errors: number }> = {};
      payers.forEach(payerId => {
        payerMetrics[payerId] = {
          claimsProcessed: parseInt(results[idx++][1] as string || '0'),
          errors: parseInt(results[idx++][1] as string || '0'),
        };
      });

      return {
        totalClaimsIngested,
        totalClaimsProcessed,
        totalRemittancesGenerated,
        totalErrors,
        payerMetrics,
        startTime,
      };
    } catch (error) {
      logger.error('Failed to get metrics:', error);
      return {
        totalClaimsIngested: 0,
        totalClaimsProcessed: 0,
        totalRemittancesGenerated: 0,
        totalErrors: 0,
        payerMetrics: {},
        startTime: Date.now(),
      };
    }
  }

  async initializeStartTime(): Promise<void> {
    try {
      const exists = await this.redis.exists(`${this.METRICS_PREFIX}start_time`);
      if (!exists) {
        await this.redis.set(`${this.METRICS_PREFIX}start_time`, Date.now());
        logger.info('Initialized metrics start time');
      }
    } catch (error) {
      logger.error('Failed to initialize start time:', error);
    }
  }

  async resetMetrics(): Promise<void> {
    try {
      const keys = await this.redis.keys(`${this.METRICS_PREFIX}*`);
      if (keys.length > 0) {
        await this.redis.del(...keys);
        logger.info('Reset all metrics');
      }
      await this.initializeStartTime();
    } catch (error) {
      logger.error('Failed to reset metrics:', error);
    }
  }
}